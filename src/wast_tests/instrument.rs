use finite_wasm::{gas::InstrumentationKind, Module};
use wasm_encoder as we;
use wasmparser as wp;
use we::Section;

const PLACEHOLDER_FOR_NAMES: u8 = !0;
/// These function indices are known to be constant, as they are added at the beginning of the
/// imports section.
///
/// Doing so makes it much easier to transform references to other functions (basically add 2 to
/// all function indices)
const GAS_INSTRUMENTATION_FN: u32 = 0;

/// See [`GAS_INSTRUMENTATION_FN`].
const STACK_INSTRUMENTATION_FN: u32 = 1;

#[derive(thiserror::Error, Debug)]
pub(crate) enum Error {
    #[error("could not parse an element")]
    ParseElement(#[source] wp::BinaryReaderError),
    #[error("could not parse an element item")]
    ParseElementItem(#[source] wp::BinaryReaderError),
    #[error("could not parse an element expression")]
    ParseElementExpression(#[source] wp::BinaryReaderError),
    #[error("could not parse the function locals")]
    ParseLocals(#[source] wp::BinaryReaderError),
    #[error("could not parse a function local")]
    ParseLocal(#[source] wp::BinaryReaderError),
    #[error("could not parse the function operators")]
    ParseOperators(#[source] wp::BinaryReaderError),
    #[error("could not parse an operator")]
    ParseOperator(#[source] wp::BinaryReaderError),
    #[error("could not parse an export")]
    ParseExport(#[source] wp::BinaryReaderError),
    #[error("could not parse a global")]
    ParseGlobal(#[source] wp::BinaryReaderError),
    #[error("could not parse a name section entry")]
    ParseName(#[source] wp::BinaryReaderError),
    #[error("could not parse a name map entry")]
    ParseNameMapName(#[source] wp::BinaryReaderError),
    #[error("could not parse an indirect name map entry")]
    ParseIndirectNameMapName(#[source] wp::BinaryReaderError),
    #[error("could not parse a module section header")]
    ParseModuleSection(#[source] wp::BinaryReaderError),
    #[error("could not parse a type section entry")]
    ParseType(#[source] wp::BinaryReaderError),
    #[error("could not parse an import section entry")]
    ParseImport(#[source] wp::BinaryReaderError),
    #[error("could not parse a constant expression operator")]
    ParseConstExprOperator(#[source] wp::BinaryReaderError),
}

impl<'a> crate::test::TestContext {
    pub(crate) fn instrument(&self, wasm: &[u8], analysis: Module) -> Result<Vec<u8>, Error> {
        let mut output = wasm_encoder::Module::new();
        let mut new_type_section = we::TypeSection::new();
        let mut new_import_section = we::ImportSection::new();
        let mut new_code_section = we::CodeSection::new();
        let mut new_element_section = we::ElementSection::new();
        let mut new_export_section = we::ExportSection::new();
        let mut new_name_section = we::NameSection::new();
        let mut new_global_section = we::GlobalSection::new();
        let mut new_start_section = we::StartSection { function_index: 0 };
        let mut raw_sections = vec![];
        let section_placeholder = |id: u8| -> we::RawSection { we::RawSection { id, data: &[] } };

        let parser = wp::Parser::new(0);
        for payload in parser.parse_all(wasm) {
            let payload = payload.map_err(Error::ParseModuleSection)?;
            match payload {
                // These two payload types are (re-)generated by wasm_encoder.
                wp::Payload::Version { .. } => {}
                wp::Payload::End(_) => {}
                // We must manually reconstruct the type section because we’re appending types to
                // it.
                wp::Payload::TypeSection(types) => {
                    for ty in types {
                        let ty = ty.map_err(Error::ParseType)?;
                        match ty {
                            wp::Type::Func(f) => {
                                new_type_section.function(
                                    f.params().iter().copied().map(valtype),
                                    f.results().iter().copied().map(valtype),
                                );
                            }
                        }
                    }
                }
                // We must manually reconstruct the imports section because we’re appending imports
                // to it.
                wp::Payload::ImportSection(imports) => {
                    maybe_add_imports(&mut new_type_section, &mut new_import_section);
                    self.transform_imports_section(imports, &mut new_import_section)?;
                }
                wp::Payload::StartSection { func, .. } => {
                    new_start_section.function_index = func + 2;
                    raw_sections.push(section_placeholder(new_start_section.id()));
                }
                wp::Payload::ElementSection(reader) => {
                    self.transform_elem_section(reader, &mut new_element_section)?;
                    raw_sections.push(section_placeholder(new_element_section.id()));
                }
                wp::Payload::CodeSectionStart { .. } => {
                    raw_sections.push(section_placeholder(new_code_section.id()));
                }
                wp::Payload::CodeSectionEntry(reader) => {
                    maybe_add_imports(&mut new_type_section, &mut new_import_section);
                    self.transform_code_section(reader, &mut new_code_section, &analysis, wasm)?;
                }
                wp::Payload::ExportSection(reader) => {
                    for export in reader {
                        let export = export.map_err(Error::ParseExport)?;
                        let (kind, index) = match export.kind {
                            wp::ExternalKind::Func => (we::ExportKind::Func, export.index + 2),
                            wp::ExternalKind::Table => (we::ExportKind::Table, export.index),
                            wp::ExternalKind::Memory => (we::ExportKind::Memory, export.index),
                            wp::ExternalKind::Global => (we::ExportKind::Global, export.index),
                            wp::ExternalKind::Tag => (we::ExportKind::Tag, export.index),
                        };
                        new_export_section.export(export.name, kind, index);
                    }
                    raw_sections.push(section_placeholder(new_export_section.id()));
                }
                wp::Payload::GlobalSection(reader) => {
                    for global in reader {
                        let global = global.map_err(Error::ParseGlobal)?;
                        new_global_section.global(
                            we::GlobalType {
                                val_type: valtype(global.ty.content_type),
                                mutable: global.ty.mutable,
                            },
                            &constexpr(global.init_expr)?,
                        );
                    }
                    raw_sections.push(section_placeholder(new_global_section.id()));
                }
                wp::Payload::CustomSection(reader) if reader.name() == "name" => {
                    let names = wp::NameSectionReader::new(reader.data(), reader.data_offset());
                    self.transform_name_section(names, &mut new_name_section)?;
                    raw_sections.push(section_placeholder(PLACEHOLDER_FOR_NAMES));
                }
                // All the other sections are transparently copied over (they cannot reference a
                // function id, or we don’t know how to handle it anyhow)
                _ => {
                    let (id, range) = payload
                        .as_section()
                        .expect("any non-section payloads should have been handled already");
                    raw_sections.push(wasm_encoder::RawSection {
                        id,
                        data: &wasm[range],
                    });
                }
            }
        }

        // The type and import sections always come first in a module. They may potentially be
        // preceded or interspersed by custom sections in the original module, so we’re just hoping
        // that the ordering doesn’t matter for tests…
        output.section(&new_type_section);
        output.section(&new_import_section);
        for section in raw_sections {
            match section.id {
                id if id == new_code_section.id() => output.section(&new_code_section),
                id if id == new_element_section.id() => output.section(&new_element_section),
                id if id == new_export_section.id() => output.section(&new_export_section),
                id if id == new_global_section.id() => output.section(&new_global_section),
                id if id == new_start_section.id() => output.section(&new_start_section),
                PLACEHOLDER_FOR_NAMES => output.section(&new_name_section),
                _ => output.section(&section),
            };
        }

        Ok(output.finish())
    }

    fn transform_code_section(
        &self,
        reader: wp::FunctionBody,
        new_code_section: &mut we::CodeSection,
        analysis: &Module,
        wasm: &[u8],
    ) -> Result<(), Error> {
        let locals = reader
            .get_locals_reader()
            .map_err(Error::ParseLocals)?
            .into_iter()
            .map(|v| v.map(|(c, t)| (c, valtype(t))))
            .collect::<Result<Vec<_>, _>>()
            .map_err(Error::ParseLocal)?;
        let mut new_function = we::Function::new(locals);
        let code_idx = new_code_section.len() as usize;
        // Reserve the stack.
        new_function.instruction(&we::Instruction::I64Const(
            analysis.function_operand_stack_sizes[code_idx] as i64,
        ));
        new_function.instruction(&we::Instruction::I64Const(
            analysis.function_frame_sizes[code_idx] as i64,
        ));
        new_function.instruction(&we::Instruction::Call(STACK_INSTRUMENTATION_FN));
        let gas_offsets = &analysis.gas_offsets[code_idx];
        let gas_costs = &analysis.gas_costs[code_idx];
        let gas_kinds = &analysis.gas_kinds[code_idx];

        let mut instrumentation_points = gas_offsets
            .iter()
            .zip(gas_costs.iter())
            .zip(gas_kinds.iter())
            .peekable();

        let mut operators = reader
            .get_operators_reader()
            .map_err(Error::ParseOperators)?;
        while !operators.eof() {
            let (op, offset) = operators.read_with_offset().map_err(Error::ParseOperator)?;
            let end_offset = operators.original_position();
            if instrumentation_points.peek().map(|((o, _), _)| **o) == Some(offset) {
                let ((_, g), k) = instrumentation_points.next().unwrap();
                if !matches!(k, InstrumentationKind::Unreachable) && *g != 0 {
                    new_function.instruction(&we::Instruction::I64Const(*g as i64));
                    new_function.instruction(&we::Instruction::Call(GAS_INSTRUMENTATION_FN));
                }
            }
            match op {
                wp::Operator::RefFunc { function_index } => {
                    new_function.instruction(&we::Instruction::RefFunc(function_index + 2))
                }
                wp::Operator::Call { function_index } => {
                    new_function.instruction(&we::Instruction::Call(function_index + 2))
                }
                wp::Operator::ReturnCall { function_index } => {
                    new_function.instruction(&we::Instruction::ReturnCall(function_index + 2))
                }
                _ => new_function.raw(wasm[offset..end_offset].iter().copied()),
            };
        }
        new_code_section.function(&new_function);
        Ok(())
    }

    fn transform_imports_section(
        &self,
        imports: wp::ImportSectionReader,
        new_import_section: &mut we::ImportSection,
    ) -> Result<(), Error> {
        for import in imports {
            let import = import.map_err(Error::ParseImport)?;
            let import_ty = match import.ty {
                wp::TypeRef::Func(i) => we::EntityType::Function(i),
                wp::TypeRef::Table(t) => we::EntityType::Table(we::TableType {
                    element_type: valtype(t.element_type),
                    minimum: t.initial,
                    maximum: t.maximum,
                }),
                wp::TypeRef::Memory(t) => we::EntityType::Memory(we::MemoryType {
                    minimum: t.initial,
                    maximum: t.maximum,
                    memory64: t.memory64,
                    shared: t.shared,
                }),
                wp::TypeRef::Global(t) => we::EntityType::Global(we::GlobalType {
                    val_type: valtype(t.content_type),
                    mutable: t.mutable,
                }),
                wp::TypeRef::Tag(t) => we::EntityType::Tag(we::TagType {
                    kind: match t.kind {
                        wp::TagKind::Exception => we::TagKind::Exception,
                    },
                    func_type_idx: t.func_type_idx,
                }),
            };
            new_import_section.import(import.module, import.name, import_ty);
        }
        Ok(())
    }

    fn transform_elem_section(
        &self,
        reader: wp::ElementSectionReader,
        new_element_section: &mut we::ElementSection,
    ) -> Result<(), Error> {
        for elem in reader {
            let elem = elem.map_err(Error::ParseElement)?;
            let functions;
            let expressions;
            let offset;
            let items = match elem.items {
                wp::ElementItems::Functions(fns) => {
                    functions = fns
                        .into_iter()
                        .map(|v| Ok(v.map_err(Error::ParseElementItem)? + 2))
                        .collect::<Result<Vec<_>, _>>()?;
                    we::Elements::Functions(&functions)
                }
                wp::ElementItems::Expressions(exprs) => {
                    expressions = exprs
                        .into_iter()
                        .map(|v| v.map_err(Error::ParseElementExpression).and_then(constexpr))
                        .collect::<Result<Vec<_>, _>>()?;
                    we::Elements::Expressions(&expressions)
                }
            };
            new_element_section.segment(we::ElementSegment {
                mode: match elem.kind {
                    wp::ElementKind::Passive => we::ElementMode::Passive,
                    wp::ElementKind::Declared => we::ElementMode::Declared,
                    wp::ElementKind::Active {
                        table_index,
                        offset_expr,
                    } => {
                        offset = constexpr(offset_expr)?;
                        we::ElementMode::Active {
                            table: Some(table_index),
                            offset: &offset,
                        }
                    }
                },
                element_type: valtype(elem.ty),
                elements: items,
            });
        }
        Ok(())
    }

    fn transform_name_section(
        &self,
        names: wp::NameSectionReader,
        new_name_section: &mut we::NameSection,
    ) -> Result<(), Error> {
        for name in names {
            let name = name.map_err(Error::ParseName)?;
            match name {
                wp::Name::Module { name, .. } => new_name_section.module(name),
                wp::Name::Function(map) => {
                    let mut new_name_map = namemap(map, true)?;
                    new_name_map.append(GAS_INSTRUMENTATION_FN, "finite_wasm_gas");
                    new_name_map.append(STACK_INSTRUMENTATION_FN, "finite_wasm_stack");
                    new_name_section.functions(&new_name_map)
                }
                wp::Name::Local(map) => new_name_section.locals(&indirectnamemap(map)?),
                wp::Name::Label(map) => new_name_section.labels(&indirectnamemap(map)?),
                wp::Name::Type(map) => new_name_section.types(&namemap(map, false)?),
                wp::Name::Table(map) => new_name_section.tables(&namemap(map, false)?),
                wp::Name::Memory(map) => new_name_section.memories(&namemap(map, false)?),
                wp::Name::Global(map) => new_name_section.globals(&namemap(map, false)?),
                wp::Name::Element(map) => new_name_section.elements(&namemap(map, false)?),
                wp::Name::Data(map) => new_name_section.data(&namemap(map, false)?),
                wp::Name::Unknown { .. } => {}
            }
        }
        Ok(())
    }
}

fn valtype(wp: wp::ValType) -> we::ValType {
    match wp {
        wp::ValType::I32 => we::ValType::I32,
        wp::ValType::I64 => we::ValType::I64,
        wp::ValType::F32 => we::ValType::F32,
        wp::ValType::F64 => we::ValType::F64,
        wp::ValType::V128 => we::ValType::V128,
        wp::ValType::FuncRef => we::ValType::FuncRef,
        wp::ValType::ExternRef => we::ValType::ExternRef,
    }
}

fn constexpr(ep: wp::ConstExpr) -> Result<we::ConstExpr, Error> {
    let mut reader = ep.get_binary_reader();
    Ok(
        match reader
            .clone()
            .read_operator()
            .map_err(Error::ParseConstExprOperator)?
        {
            wp::Operator::RefFunc { function_index } => we::ConstExpr::ref_func(function_index + 2),
            _ => {
                let expr_bytes = reader
                    .read_bytes(reader.bytes_remaining())
                    .expect("can't fail");
                // ConstExpr introduces its own `End` operand, so we want want to drop it.
                let without_end = &expr_bytes[0..expr_bytes.len() - 1];
                we::ConstExpr::raw(without_end.iter().copied())
            }
        },
    )
}

fn namemap(p: wp::NameMap, is_function: bool) -> Result<we::NameMap, Error> {
    let mut new_name_map = we::NameMap::new();
    for naming in p {
        let naming = naming.map_err(Error::ParseNameMapName)?;
        new_name_map.append(naming.index + (2u32 * is_function as u32), naming.name);
    }
    Ok(new_name_map)
}

fn indirectnamemap(p: wp::IndirectNameMap) -> Result<we::IndirectNameMap, Error> {
    let mut new_name_map = we::IndirectNameMap::new();
    for naming in p {
        let naming = naming.map_err(Error::ParseIndirectNameMapName)?;
        new_name_map.append(naming.index + 2, &namemap(naming.names, false)?);
    }
    Ok(new_name_map)
}

fn maybe_add_imports(ts: &mut we::TypeSection, is: &mut we::ImportSection) {
    if is.is_empty() {
        let instrument_fn_ty = ts.len();
        // By adding the type at the end of the type section we guarantee that any other
        // type references remain valid.
        ts.function([we::ValType::I64], []);
        ts.function([we::ValType::I64, we::ValType::I64], []);
        // By inserting the imports at the beginning of the import section we make the new
        // function index mapping trivial (it is always just an increment by 2)
        is.import(
            "spectest",
            "finite_wasm_gas",
            we::EntityType::Function(instrument_fn_ty),
        );
        is.import(
            "spectest",
            "finite_wasm_stack",
            we::EntityType::Function(instrument_fn_ty + 1),
        );
    }
}
